---
id: cc-AMONGUS2
source: CC
title: Among Us
author: Ryan Chou
---

## Explanation
If we only have two players $x$ and $y$, then we have 4 cases possible cases. 

* If $x$ vouches for $y$ and $x$ is an imposter, then $y$ must also be an imposter.

* If $x$ vouches for $y$ and $x$ is a crewmate, then $y$ must also be a crewmate.

* If $x$ accuses $y$ of being an imposter and $x$ is an imposter, then $y$ must be a crewmate.

* If $x$ accuses $y$ of being an imposter and $x$ is a crewmate, then $y$ must be an imposter.

You'll notice that whenever $x$ accuses $y$, they'll always be of a different type, and when $x$ vouches for $y$, they'll always be of the same type.

With this information, we can build a bipartite graph and color nodes with the same color if they vouch for each other, or different colors if one of them accuses the other. If we can't build this graph, then no valid arrangement can exist.

Otherwise, we'll consider each connected component independently and keep track of the number of crewmates and imposters. At the end, we'll return the sum of the maximum of these two values for all connected components. We don't care about the roles of each node because we can switch all of them to get another valid solution.

## Implementation
**Time Complexity:** $\mathcal{O}(N)$

<LanguageSection>
<CPPSection>

```cpp
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

int main() {
	int t;
	cin >> t;

	for (int tc = 0; tc < t; tc++) {
		int n;
		int q;
		cin >> n >> q;
		
		// adj[i][j] = {the jth adjacent node from i, their statement (0 = imposter, 1 = crewmate)
		vector<vector<pair<int, bool>>> adj(n);
		for (int i = 0; i < q; i++) {
			int type;
			int x;
			int y;
			cin >> type >> x >> y;
			--x;
			--y;
			--type;
	
			adj[x].push_back({y, type});
			adj[y].push_back({x, type});
		}

		vector<int> role(n, -1);

		int ans = 0;
		bool impossible = false;

		for (int i = 0; i < n; i++) {
			// haven't visited this connected component yet
			if (role[i] == -1) {
				int imposters = 0, crewmates = 0;

				// dfs to build bipartite graph
				stack<int> todo;

				todo.push(i);
				role[i] = true;
				imposters++;

				while (!todo.empty()) {
					int curr = todo.top();
					todo.pop();
					
					for (pair<int, bool> u : adj[curr]) {
						bool type = u.second ? role[curr] : !role[curr];

						// haven't visited
						if (role[u.first] == -1) {
							role[u.first] = type;
								
								if (type) {
									imposters++;
								} else {
									crewmates++;
								}
					
							todo.push(u.first);
						// creates a contradiction
						} else if (role[u.first] == !type) {
							impossible = true;
							break;
						}
					}
				}
				ans += max(imposters, crewmates);
			}
		}

		cout << (impossible ? -1 : ans) << endl;
	}
}
```
</CPPSection>


<JavaSection>

```java

import java.util.*;
import java.io.*;
public class Main {
    static boolean[] visited;
    static ArrayList < ArrayList < pair >> adj;
    static int size;
    static int cur;
    static int[] ans;
    static boolean good;
    public static void main(String[] args) throws IOException {
        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(System.out);
        int t = Integer.parseInt(f.readLine());
        while (t-- > 0) {
            good = true;
            StringTokenizer st = new StringTokenizer(f.readLine());
            int n = Integer.parseInt(st.nextToken());
            int m = Integer.parseInt(st.nextToken());
            adj = new ArrayList < ArrayList < pair >> ();
            ans = new int[n];
            for (int i = 0; i < n; i++) {
                adj.add(new ArrayList < pair > ());
                ans[i] = -1;
            }
            for (int i = 0; i < m; i++) {
                st = new StringTokenizer(f.readLine());
                int type = Integer.parseInt(st.nextToken());
                int x = Integer.parseInt(st.nextToken()) - 1;
                int y = Integer.parseInt(st.nextToken()) - 1;
                adj.get(x).add(new pair(y, type));
                adj.get(y).add(new pair(x, type));
            }
            int res = 0;
            visited = new boolean[n];
            for (int i = 0; i < n; i++) {
                if (!visited[i]) {
                    cur = 0;
                    size = 1;
                    ans[i] = 0;
                    dfs(i);
                    res += Math.max(cur, size - cur);
                }
            }
            if (!good) {
                out.println(-1);
            } else {
                out.println(res);
            }
        }

        out.close();
        f.close();
    }
    public static void dfs(int i) {
        if (visited[i]) return;
        visited[i] = true;
        for (pair p: adj.get(i)) {
            if (ans[p.first] == -1) {
                if (p.second == 1) {
                    ans[p.first] = 1 - ans[i];
                } else {
                    ans[p.first] = ans[i];
                }
                cur += ans[p.first];
                size++;
                dfs(p.first);
            } else {
                if (p.second == 1) {
                    if (ans[p.first] == ans[i]) {
                        good = false;
                    }
                } else {
                    if (ans[p.first] != ans[i]) {
                        good = false;
                    }
                }
            }
        }
    }
    static class pair {
        int first, second;
        public pair(int a, int b) {
            first = a;
            second = b;
        }
    }
}


```


</JavaSection>
</LanguageSection>
